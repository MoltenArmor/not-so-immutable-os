#!/bin/sh
set -ue

# Ensure cleanup completes even if interrupted
cleanup_on_interrupt() {
    # Always try to restore on interrupt
    restore_etc || :
    restore_usr || :
    restore_package_metadata || :
}

trap cleanup_on_interrupt INT TERM

usage() {
    printf '%s\n' 'Usage: exit-rw'
    printf '%s\n' 'Exit testing mode and restore /etc and /usr.'
}

check_user() {
    if [ "$(id -u)" -ne 0 ]; then
        printf '%s\n' "Error: This script must be run as root." >&2
        exit 1
    fi
}

is_sysext_merged() {
    [ -d /usr/.systemd-sysext/ ]
}

is_confext_merged() {
    [ -d /etc/.systemd-confext/ ]
}

is_dir_tmpified() {
    [ -n "${1:-}" ] || return 1
    findmnt -t overlay -T "$1" 2>/dev/null | grep -qF 'upperdir=/run/tmpify'
}

restore_usr() {
    if is_sysext_merged; then
        systemctl --no-block try-reload-or-restart systemd-sysext.service
    elif is_dir_tmpified /usr; then
        tmpify -r /usr || :
    fi
}

restore_etc() {
    if is_confext_merged; then
        systemctl --no-block try-reload-or-restart systemd-confext.service
    elif is_dir_tmpified /etc; then
        tmpify -r /etc || :
    fi
}

restore_package_metadata() {
    if is_dir_tmpified /var/lib/apt; then
        tmpify -r /var/lib/apt || :
    fi

    if is_dir_tmpified /var/lib/dpkg; then
        tmpify -r /var/lib/dpkg || :
    fi
}

while [ "$#" -gt 0 ]; do
    case "$1" in
        '-h' | '--help')
            usage
            exit 0
            ;;
        -*)
            printf '%s\n' "Unknown option: $1" >&2
            usage
            exit 2
            ;;
        *)
            printf '%s\n' "Error: This command takes no arguments." >&2
            usage
            exit 2
            ;;
    esac
done

check_user

restore_etc
restore_usr
restore_package_metadata

printf '%s\n' 'Exited RW mode.'
exit 0
